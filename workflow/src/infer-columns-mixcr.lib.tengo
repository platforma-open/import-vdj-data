maps := import("@platforma-sdk/workflow-tengo:maps")
slices := import("@platforma-sdk/workflow-tengo:slices")
json := import("json")
ll := import("@platforma-sdk/workflow-tengo:ll")
text := import("text")

common := import(":infer-columns-common")
a := common.a
readColumnSpecs := common.readColumnSpecs
umiColumnSpecs := common.umiColumnSpecs
propertyColumnSpecs := common.propertyColumnSpecs

// MiXCR header aliases (common column names)
sourceAliases := {
    // Abundance
    "readCount": "read-count",   
    "readFraction": "read-fraction",
    "uniqueMoleculeCount": "umi-count",
    "umiCount": "umi-count",

    // Sequences
    "nSeqCDR3": "cdr3-nt",
    "aaSeqCDR3": "cdr3-aa",
    "nSeqFR1": "fr1-nt",
    "nSeqCDR1": "cdr1-nt",
    "nSeqCDR2": "cdr2-nt",
    "nSeqFR2": "fr2-nt",
    "nSeqFR3": "fr3-nt",
    "nSeqFR4": "fr4-nt",
    "aaSeqFR1": "fr1-aa",
    "aaSeqCDR1": "cdr1-aa",
    "aaSeqFR2": "fr2-aa",
    "aaSeqCDR2": "cdr2-aa",
    "aaSeqFR3": "fr3-aa",
    "aaSeqFR4": "fr4-aa",
    "nSeqVDJRegion": "vdj-nt",
    "aaSeqVDJRegion": "vdj-aa",
    "isotype": "isotype",

    // Best genes (desired outputs)
    "bestVGene": "v-gene",
    "bestDGene": "d-gene",
    "bestJGene": "j-gene",
    "bestCGene": "c-gene",

    // Best alleles
    "bestVHit": "v-allele",
    "bestDHit": "d-allele",
    "bestJHit": "j-allele",
    "bestCHit": "c-allele",

    // Alternate inputs that may require conversion to bestXGene
    "allVHitsWithScore": "allVHitsWithScore",
    "allDHitsWithScore": "allDHitsWithScore",
    "allJHitsWithScore": "allJHitsWithScore",
    "allCHitsWithScore": "allCHitsWithScore",

    "allVHits": "allVHits",
    "allDHits": "allDHits",
    "allJHits": "allJHits",
    "allCHits": "allCHits",

    "allVGenes": "allVGenes",
    "allDGenes": "allDGenes",
    "allJGenes": "allJGenes",
    "allCGenes": "allCGenes"
}

requiredColumns := ["read-count", "cdr3-nt", "cdr3-aa"]

getColumns := func(header) {
    columnMapping := {}
    for h in header {
        s := sourceAliases[h]
        if s != undefined && columnMapping[s] == undefined {
            columnMapping[s] = h
        }
    }

    // Detect single-cell tag columns: accept MiXCR variants 'tagValueCELL' and case-insensitive 'tagValueCell*'
    isSingleCell := false
    cellTagColumns := []
    for h in header {
        if text.re_match("^(?i)tagValueCell", h) {
            isSingleCell = true
            // Preserve original header name; also expose canonical mapping to itself
            // Ensure we don't add duplicates if the header appears multiple times
            alreadyAdded := false
            for ex in cellTagColumns { if ex == h { alreadyAdded = true } }
            if !alreadyAdded {
                cellTagColumns = append(cellTagColumns, h)
            }
            if columnMapping[h] == undefined { columnMapping[h] = h }
        }
    }

    // ll.print("sc tags:", cellTagColumns)
   
    // Validate minimal requirements (do not panic; UI will show alert)
    missingRequired := []
    for col in requiredColumns {
        if is_undefined(columnMapping[col]) {
            missingRequired = append(missingRequired, col)
        }
    }

    // No allele fallbacks: only use allele columns if the source bestXHit is present

    hasUMIs := !is_undefined(columnMapping["umi-count"]) || !is_undefined(columnMapping["umi-fraction"])

    // Include available abundance types only; avoid referencing missing specs
    abundanceColumns := {}
    hasReads := !is_undefined(columnMapping["read-count"]) || !is_undefined(columnMapping["read-fraction"])
    if hasReads {
        abundanceColumns = maps.merge(abundanceColumns, readColumnSpecs)
    }
    if hasUMIs {
        abundanceColumns = maps.merge(abundanceColumns, umiColumnSpecs)
    }
    mainAbundance := hasUMIs ? "umi-count" : (hasReads ? "read-count" : "")
    mainFractionAbundance := hasUMIs ? "umi-fraction" : (hasReads ? "read-fraction" : "")

    if mainAbundance != "" && abundanceColumns[mainAbundance] != undefined {
        abundanceColumns[mainAbundance].spec.annotations["pl7.app/abundance/isPrimary"] = "true"
        abundanceColumns[mainAbundance].spec.annotations["pl7.app/isAnchor"] = "true"
    }
    if mainFractionAbundance != "" && abundanceColumns[mainFractionAbundance] != undefined {
        abundanceColumns[mainFractionAbundance].spec.annotations["pl7.app/abundance/isPrimary"] = "true"
    }

    // Property columns we will show
    // Always include main sequences and gene hits (v/d/j/c)
    propertyColumns := [
        propertyColumnSpecs["cdr3-nt"],
        propertyColumnSpecs["cdr3-aa"],
        propertyColumnSpecs["cdr3-aa-length"],
        propertyColumnSpecs["cdr3-nt-length"],
        propertyColumnSpecs["is-productive"],
        propertyColumnSpecs["v-gene"],
        propertyColumnSpecs["d-gene"],
        propertyColumnSpecs["j-gene"],
        propertyColumnSpecs["c-gene"]
    ]
    // Include allele columns if any of bestXHit/allXHits/allXHitsWithScore present in header
    if columnMapping["v-allele"] != undefined || columnMapping["allVHits"] != undefined || columnMapping["allVHitsWithScore"] != undefined {
        propertyColumns = append(propertyColumns, propertyColumnSpecs["v-allele"]) 
    }
    if columnMapping["d-allele"] != undefined || columnMapping["allDHits"] != undefined || columnMapping["allDHitsWithScore"] != undefined {
        propertyColumns = append(propertyColumns, propertyColumnSpecs["d-allele"]) 
    }
    if columnMapping["j-allele"] != undefined || columnMapping["allJHits"] != undefined || columnMapping["allJHitsWithScore"] != undefined {
        propertyColumns = append(propertyColumns, propertyColumnSpecs["j-allele"]) 
    }
    if columnMapping["c-allele"] != undefined || columnMapping["allCHits"] != undefined || columnMapping["allCHitsWithScore"] != undefined {
        propertyColumns = append(propertyColumns, propertyColumnSpecs["c-allele"]) 
    }
	// Optional FR/CDR/isotype feature columns
	optKeys := [
		"fr1-nt", "cdr1-nt", "fr2-nt", "fr3-nt", "fr4-nt",
		"fr1-aa", "cdr1-aa", "fr2-aa", "cdr2-aa", "fr3-aa", "fr4-aa",
        "vdj-nt", "vdj-aa", "isotype"
	]
	for k in optKeys {
		if columnMapping[k] != undefined {
			propertyColumns = append(propertyColumns, propertyColumnSpecs[k])
		}
	}

	// Do not add these to propertyColumns; tag values are internal and used only to derive cellKey

    // Check for present sequences
    presentFrCdrNt := columnMapping["fr1-nt"] != undefined && 
                        columnMapping["cdr1-nt"] != undefined && 
                        columnMapping["fr2-nt"] != undefined && 
                        columnMapping["cdr2-nt"] != undefined && 
                        columnMapping["fr3-nt"] != undefined
    presentFrCdrAa := columnMapping["fr1-aa"] != undefined && 
                        columnMapping["cdr1-aa"] != undefined && 
                        columnMapping["fr2-aa"] != undefined && 
                        columnMapping["cdr2-aa"] != undefined && 
                        columnMapping["fr3-aa"] != undefined
	hasCdr3Nt := columnMapping["cdr3-nt"] != undefined
	hasCdr3Aa := columnMapping["cdr3-aa"] != undefined
	useFrCdr := presentFrCdrNt && (hasCdr3Nt || hasCdr3Aa)
    hasFr4Nt := columnMapping["fr4-nt"] != undefined
    hasVdjNt := columnMapping["vdj-nt"] != undefined
    hasVdjAa := columnMapping["vdj-aa"] != undefined

    // Add specs for columns that will be computed from existing ones
    if (hasVdjNt == false) && (presentFrCdrNt && hasCdr3Nt) {
        propertyColumns = append(propertyColumns, propertyColumnSpecs["vdj-nt"])
    }
    if (hasVdjAa == false) && (presentFrCdrAa && hasCdr3Aa) {
        propertyColumns = append(propertyColumns, propertyColumnSpecs["vdj-aa"])
    }

    // Build clonotype key based on AA or NT (prefer NT if present), plus V/J and optional C gene
    keyColumns := []
    keyStructure := ""
    if hasVdjNt || (presentFrCdrNt && hasCdr3Nt) {
        keyColumns = append(keyColumns, "vdj-nt")
        keyStructure = "VDJRegion"
    } else if useFrCdr {
		keyColumns = ["fr1-nt", "cdr1-nt", "fr2-nt", "cdr2-nt", "fr3-nt", (hasCdr3Nt ? "cdr3-nt" : "cdr3-aa")]
        if hasFr4Nt { keyColumns = append(keyColumns, "fr4-nt") }
        keyStructure = "FR1nt-CDR1nt-FR2nt-CDR2nt-FR3nt-" + (hasCdr3Nt ? "CDR3nt" : "CDR3aa") + (hasFr4Nt ? "-FR4nt" : "")
	} else if hasCdr3Nt {
		keyColumns = append(keyColumns, "cdr3-nt")
        keyStructure = keyStructure + "CDR3-nt"
	} else if hasCdr3Aa {
		keyColumns = append(keyColumns, "cdr3-aa")
        keyStructure = keyStructure + "CDR3-aa"
	}
	// Include v-gene and j-gene in key if available (either directly or derivable from all* columns)
	hasVGeneInKey := columnMapping["v-gene"] != undefined || 
		columnMapping["v-allele"] != undefined || 
		columnMapping["allVHitsWithScore"] != undefined || 
		columnMapping["allVHits"] != undefined || 
		columnMapping["allVGenes"] != undefined
	if hasVGeneInKey {
        keyColumns = append(keyColumns, "v-gene")
        keyStructure = keyStructure + "-VGene"
    }
	hasJGeneInKey := columnMapping["j-gene"] != undefined || 
		columnMapping["j-allele"] != undefined || 
		columnMapping["allJHitsWithScore"] != undefined || 
		columnMapping["allJHits"] != undefined || 
		columnMapping["allJGenes"] != undefined
	if hasJGeneInKey {
        keyColumns = append(keyColumns, "j-gene")
        keyStructure = keyStructure + "-JGene"
    }
    includeCGene := columnMapping["c-gene"] != undefined 
	if includeCGene { 
        keyColumns = append(keyColumns, "c-gene") 
        keyStructure = keyStructure + "-CGene"
    }

    // define mainSequence and assemblingFeature sequence columns
    // Only the specs for which we have columns will be loaded
    // @TODO: check this. For now we just set vdj as main if we have aa and nt
    if (hasVdjNt && hasVdjAa) || ((presentFrCdrNt && hasCdr3Nt) && (presentFrCdrAa && hasCdr3Aa)) {
        propertyColumnSpecs["vdj-nt"].spec.annotations["pl7.app/vdj/isMainSequence"] = "true"
        propertyColumnSpecs["vdj-nt"].spec.annotations["pl7.app/vdj/isAssemblingFeature"] = "true"
        propertyColumnSpecs["vdj-aa"].spec.annotations["pl7.app/vdj/isMainSequence"] = "true"
        propertyColumnSpecs["vdj-aa"].spec.annotations["pl7.app/vdj/isAssemblingFeature"] = "true"
    } else {
        propertyColumnSpecs["cdr3-nt"].spec.annotations["pl7.app/vdj/isMainSequence"] = "true"
        propertyColumnSpecs["cdr3-nt"].spec.annotations["pl7.app/vdj/isAssemblingFeature"] = "true"
        propertyColumnSpecs["cdr3-aa"].spec.annotations["pl7.app/vdj/isMainSequence"] = "true"
        propertyColumnSpecs["cdr3-aa"].spec.annotations["pl7.app/vdj/isAssemblingFeature"] = "true"
    }

    return {
        hasUMIs: hasUMIs,
        abundanceColumns: maps.getValues(abundanceColumns),
        propertyColumns: propertyColumns,
        columnMapping: columnMapping,
        clonotypeKeyStructure: keyStructure,
        clonotypeKeyColumns: keyColumns,
        cellTagColumns: cellTagColumns,
        isSingleCell: isSingleCell
    }
}

export {
    getColumns: getColumns
}


