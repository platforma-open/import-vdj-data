// process

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
sets := import("@platforma-sdk/workflow-tengo:sets")
assets := import("@platforma-sdk/workflow-tengo:assets")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
formats := import(":formats")
processUtils := import(":process-utils")

json := import("json")
text := import("text")
aggregateByClonotypeKeyTpl := assets.importTemplate(":aggregate-by-clonotype-key")

// Helper to add common annotations for table view properties
a := func(order, defaultVisibility, spec) {
	return maps.merge(spec, {
		"pl7.app/table/orderPriority": string(order),
		"pl7.app/table/visibility": is_undefined(defaultVisibility) ? "hidden" : defaultVisibility ? "default" : "optional"
	})
}

abundanceAggColumns := func(columnsInfo) {
    aggColumns := []
    unit2label := {
        "molecules": "UMIs",
        "reads": "Reads"
    }
    for column in columnsInfo.abundanceColumns {
        if column.spec.annotations["pl7.app/abundance/isPrimary"] != "true" {
            continue
        }

        unit := column.spec.annotations["pl7.app/abundance/unit"]
        descUnit := unit == "molecules" ? "UMI" : "read"
        if column.spec.annotations["pl7.app/abundance/normalized"] == "false" {
            aggColumns += [{
                column: column.column + "-total",
                id: column.id + "-total",
                allowNA: false,
                spec: {
                    name: column.spec.name + "Total",
                    valueType: "Long",
                    annotations: a(87120, false, {
                        "pl7.app/min": "1",
                        "pl7.app/isAbundance": "true",
                        "pl7.app/abundance/unit": unit,
                        "pl7.app/abundance/normalized": "false",
                        "pl7.app/label": "Supporting " + unit2label[unit],
                        "pl7.app/description": "The sum of a clonotype's " + descUnit + " counts across all samples."
                    })
                }
            }]
        } else {
            aggColumns += [{
                column: column.column + "-mean",
                id: column.id + "-mean",
                allowNA: false,
                spec: {
                    name: column.spec.name + "Mean",
                    valueType: "Double",
                    annotations: a(87130, false, {
                        "pl7.app/min": "0",
                        "pl7.app/max": "1",
                        "pl7.app/isAbundance": "true",
                        "pl7.app/abundance/unit": unit,
                        "pl7.app/abundance/normalized": "true",
                        "pl7.app/label": "Mean Fraction of " + unit2label[unit],
                        "pl7.app/description": "The average " + descUnit + " fraction of a clonotype across all samples where it is present.",
                        "pl7.app/format": ".2p"
                    })
                }
            }]
        }
    }
    return aggColumns
}

self.awaitState("InputsLocked")
self.awaitState("columnsInfo", "ResourceReady")
self.awaitState("dataset", "ResourceReady")

// self.defineOutputs("result", "stats")

self.body(func(inputs) {

    // chains to import
	chains := inputs.chains
    columnsInfo := inputs.columnsInfo
    datasetSpec := inputs.dataset.spec
    dataset := inputs.dataset.data
	format := inputs.format
    blockId := inputs.blockId

	formatSpec := formats.mustGet(format)
	importTemplates := {
		":import-common": assets.importTemplate(":import-common"),
		":import-immunoSeq": assets.importTemplate(":import-immunoSeq"),
		":import-qiagen": assets.importTemplate(":import-qiagen"),
		":import-custom": assets.importTemplate(":import-custom")
	}
	importTpl := importTemplates[formatSpec.importTplId]
	if importTpl == undefined {
		ll.panic("Unsupported import template: " + formatSpec.importTplId)
	}
	importCfg := processUtils.applyXsvType(formatSpec.importCfg, inputs.dataset.spec)

    result := pframes.pFrameBuilder()
    stats := pframes.pFrameBuilder()

    importOutputs := []
    keyStructureStr := processUtils.buildClonotypeKeyStructure(columnsInfo, columnsInfo.clonotypeKeyColumns)

    for chain in chains {

        axes := [
            {
                column: "clonotypeKey",
                naRegex: "",
                spec: {
                    type: "String",
                    name: "pl7.app/vdj/clonotypeKey",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/clonotypingRunId": blockId,
                        "pl7.app/vdj/clonotypeKey/structure": keyStructureStr
                    },
                    annotations: {
                        "pl7.app/label": "Clonotype ID",
                        "pl7.app/description": "A composite key that uniquely identifies a clonotype."
                    }
                }
            }
        ]

        statsColumns := processUtils.buildStatsColumns(chain, blockId, columnsInfo)

        if columnsInfo.hasUMIs {
            statsColumns += [{
                id: "umi-count",
                column: "umi-count",
                spec: {
                    name: "pl7.app/vdj/stat/umiCount",
                    valueType: "Long",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/clonotypingRunId": blockId
                    },
                    annotations: {
                        "pl7.app/label": "Number of UMIs",
                        "pl7.app/description": "The number of UMIs in the dataset.",
                        "pl7.app/table/visibility": "default"
                    }
                }
            }]
        }

		traceSteps := [{
			type: "milaboratories.importVDJ",
            id: blockId + ".chain",
			importance: 81,
			label: chain
		}]

        importOutputs += [
            {
                type: "Resource",
                spec: {
                    kind: "PColumn",
                    name: "mixcr.com/clonotypeTable",
                    valueType: "File"
                },
                name: "clonotypesTsv-" + chain,
                path: ["tsv", chain]
            },
            {
                type: "TsvContent",
                settings: {
                    axes: [],
                    columns: statsColumns
                },
                traceSteps: traceSteps,
                name: "stats-" + chain,
                path: ["stats", chain]
            },
            {
                type: "Xsv",
                xsvType: "tsv",
                settings: {
                    axes: axes,
                    // override trace to include chain name
                    columns: columnsInfo.abundanceColumns,
                    storageFormat: "Parquet",
                    partitionKeyLength: 0
                },
                traceSteps: traceSteps,
                mem: "16GiB",
                cpu: 2,
                name: "abundance-" + chain,
                path: ["tsv", chain]
        }]
    }

	importResults := pframes.processColumn(
		{
            spec: datasetSpec,
            data: dataset
        },
		importTpl,
		importOutputs,
		{
            // @todo all tags
            aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/tag",
				optional: true
			}],

			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			extra: {
                columnsInfo: columnsInfo,
                chains: chains,
				config: importCfg,
				primaryCountType: inputs.primaryCountType
            }
		}
	)

    for chain in chains {
        importResults.addXsvOutputToBuilder(result, "abundance-" + chain, "abundance-" + chain)
        importResults.addXsvOutputToBuilder(stats, "stats-" + chain, "stats-" + chain)
    }

    for chain in chains {
        axes := [
            {
                column: "clonotypeKey",
                naRegex: "",
                spec: {
                    type: "String",
                    name: "pl7.app/vdj/clonotypeKey",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/clonotypingRunId": blockId,
                        "pl7.app/vdj/clonotypeKey/structure": keyStructureStr
                    },
                    annotations: {
                        "pl7.app/label": "Clonotype ID",
                        "pl7.app/description": "A composite key that uniquely identifies a clonotype."
                    }
                }
            }
        ]

        propertyColumns := columnsInfo.propertyColumns
        propertyColumns += [
            {
                id: "sampleCount",
                column: "sampleCount",
                spec: {
                    name: "pl7.app/vdj/sampleCount",
                    valueType: "Int",
                    annotations: {
                        "pl7.app/label": "Number of Samples",
                        "pl7.app/description": "The number of samples in which the clonotype is detected.",
                        "pl7.app/abundance/normalized": "false",
                        "pl7.app/abundance/unit": "samples",
                        "pl7.app/isAbundance": "true",
                        "pl7.app/min": "1",
                        "pl7.app/table/orderPriority": "87110",
                        "pl7.app/table/visibility": "optional"
                    }
                }
            }, {
                id: "clonotypeLabel",
                column: "clonotypeLabel",
                spec: {
                    name: "pl7.app/label",
                    valueType: "String",
                    annotations: {
                        "pl7.app/label": "Clone label",
                        "pl7.app/description": "A short, human-readable label for the clonotype."
                    }
                }
        }]

        // Modify column visibility for TCR chains
        isTCRChain := text.has_prefix(chain, "TCR")
        if isTCRChain {
            visibilitySettings := {
                "c-gene": "optional",
                "c-allele": "optional",
                "isotype": "hidden"
            }
            propertyColumns = slices.map(propertyColumns, func(col) {
                visibility := visibilitySettings[col.column]
                if !is_undefined(visibility) {
                    return maps.deepMerge(col, {
                        spec: {
                            annotations: maps.merge(col.spec.annotations, {
                                "pl7.app/table/visibility": visibility
                            })
                        }
                    })
                }
                return col
            })
        }

        aggAbundanceColumns := abundanceAggColumns(columnsInfo)

        aggOutputs := [{
            type: "Xsv",
            xsvType: "tsv",
            settings: {
                axes: axes,
                columns: propertyColumns + aggAbundanceColumns,
                storageFormat: "Parquet",
                partitionKeyLength: 0
            },
            mem: "16GiB",
            cpu: 2,
            name: "properties-" + chain,
            path: ["tsv"]
        }]

        // Derive primary abundance names from columnsInfo primary flags to keep consistency
        mainAbundanceCount := "read-count"
        mainAbundanceFraction := "read-fraction"
        for col in columnsInfo.abundanceColumns {
            if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "false" {
                mainAbundanceCount = col.column
            }
            if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "true" {
                mainAbundanceFraction = col.column
            }
        }

        aggResults := pframes.processColumn(
            importResults.output("clonotypesTsv-" + chain),
            aggregateByClonotypeKeyTpl,
            aggOutputs,
            {
                aggregate: ["pl7.app/sampleId"],

                traceSteps: [{type: "milaboratories.importVDJ",  id: blockId + "." + chain, importance: 81, label: chain}],

                extra: {
                    primaryAbundance: mainAbundanceCount,
                    primaryFraction: mainAbundanceFraction,
                    schema: processUtils.columnsToSchema(propertyColumns)
                }
            }
        )

        aggResults.addXsvOutputToBuilder(result, "properties-" + chain, "properties-" + chain)
    }

    return {
        result: result.build(),
        stats: stats.build()
    }
})
