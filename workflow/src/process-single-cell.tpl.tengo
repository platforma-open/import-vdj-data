// process-single-cell orchestrator

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
text := import("text")
assets := import("@platforma-sdk/workflow-tengo:assets")

json := import("json")

mixcrTpl := assets.importTemplate(":import-mixcr")
cellrangerTpl := assets.importTemplate(":import-cellranger")
aggregateByClonotypeKeyTpl := assets.importTemplate(":aggregate-by-clonotype-key")
processSingleCellKeysTpl := assets.importTemplate(":process-single-cell-keys")

annot := func(order, defaultVisibility, spec) {
	return maps.merge(spec, {
		"pl7.app/table/orderPriority": string(order),
		"pl7.app/table/visibility": is_undefined(defaultVisibility) ? "hidden" : defaultVisibility ? "default" : "optional"
	})
}

columnsToSchema := func(columns) {
	schema := []
	for col in columns {
		schema += [ { column: col.column, type: col.spec.valueType } ]
	}
	return schema
}

self.awaitState("InputsLocked")
self.awaitState("columnsInfo", "ResourceReady")
self.awaitState("dataset", "ResourceReady")

self.body(func(inputs) {
	chains := inputs.chains
	columnsInfo := inputs.columnsInfo
	datasetSpec := inputs.dataset.spec
	dataset := inputs.dataset.data
	blockId := inputs.blockId
	format := inputs.format

	result := pframes.pFrameBuilder()
	stats := pframes.pFrameBuilder()

	importTpl := undefined
	if format == "mixcr-sc" {
		importTpl = mixcrTpl
	} else if format == "cellranger" {
		importTpl = cellrangerTpl
	}
	if importTpl == undefined { ll.panic("Import template is undefined, format: " + format) }

	// Import per-chain, producing clonotype and per-cell-tag TSVs
	importOutputs := []
	for chain in chains {
		axes := [
			{
				column: "clonotypeKey",
				naRegex: "",
				spec: {
					type: "String",
					name: "pl7.app/vdj/clonotypeKey",
					domain: {
						"pl7.app/vdj/chain": chain,
						"pl7.app/vdj/vdjImport": blockId,
						"pl7.app/vdj/clonotypeKey/structure": columnsInfo.clonotypeKeyStructure
					},
					annotations: {
						"pl7.app/label": "Clonotype ID",
						"pl7.app/description": "A composite key that uniquely identifies a clonotype."
					}
				}
			}
		]
		hasReads := columnsInfo.columnMapping["read-count"] != undefined
		statsColumns := [
			{
				id: "clonotype-count",
				column: "clonotype-count",
				spec: {
					name: "pl7.app/vdj/stat/clonotypeCount",
					valueType: "Int",
					domain: {
						"pl7.app/vdj/chain": chain,
						"pl7.app/vdj/vdjImport": blockId
					},
					annotations: {
						"pl7.app/label": "Number of Clonotypes",
						"pl7.app/description": "The number of clonotypes in the dataset.",
						"pl7.app/table/visibility": "default"
					}
				}
			}
		]
		if hasReads {
			statsColumns += [
				{
					id: "read-count",
					column: "read-count",
					spec: {
						name: "pl7.app/vdj/stat/readCount",
						valueType: "Long",
						domain: {
							"pl7.app/vdj/chain": chain,
							"pl7.app/vdj/vdjImport": blockId
						},
						annotations: {
							"pl7.app/label": "Number of Reads",
							"pl7.app/description": "The number of reads in the dataset.",
							"pl7.app/table/visibility": "default"
						}
					}
				}
			]
		}
		traceSteps := [{ type: "milaboratories.importVDJ", id: blockId + ".chain", importance: 81, label: chain }]
		importOutputs += [
			{
				type: "Resource",
				spec: { kind: "PColumn", name: "mixcr.com/clonotypeTable", valueType: "File" },
				name: "clonotypesTsv-" + chain,
				path: ["tsv", chain]
			},
			{
				type: "Resource",
				spec: { kind: "PColumn", name: "mixcr.com/clonotypeTableForSingleCell", valueType: "File" },
				name: "clonotypesTsvForSingleCell-" + chain,
				path: ["tsvForSingleCell", chain]
			},
			{
				type: "TsvContent",
				settings: { axes: [], columns: statsColumns },
				traceSteps: traceSteps,
				name: "stats-" + chain,
				path: ["stats", chain]
			}
		]
	}

	importResults := pframes.processColumn(
		{ spec: datasetSpec, data: dataset },
		importTpl,
		importOutputs,
		{
			aggregate: [
				{ name: "pl7.app/sequencing/lane", optional: true },
				{ name: "pl7.app/sequencing/tag", optional: true }
			],
			passAggregationAxesNames: true,
			extra: {
				columnsInfo: columnsInfo,
				chains: chains
			}
		}
	)

	for chain in chains { importResults.addXsvOutputToBuilder(stats, "stats-" + chain, "stats-" + chain) }

	// SC branch per receptor
	chainToReceptor := { "IGHeavy": "IG", "IGLight": "IG", "TCRAlpha": "TCRAB", "TCRBeta": "TCRAB", "TCRDelta": "TCRGD", "TCRGamma": "TCRGD" }

	mainAbundanceCount := "read-count"; mainAbundanceFraction := "read-fraction"
	for col in columnsInfo.abundanceColumns {
		if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "false" { mainAbundanceCount = col.column }
		if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "true" { mainAbundanceFraction = col.column }
	}
	columnsSchema := columnsToSchema(columnsInfo.propertyColumns)
	sampleIdAxisSpec := inputs.dataset.spec.axesSpec[0]
	axisByScClonotypeKey := func(receptor) {
		return {
			column: "scClonotypeKey",
			naRegex: "",
			spec: {
				name: "pl7.app/vdj/scClonotypeKey",
				type: "String",
				domain: {
					"pl7.app/vdj/receptor": receptor,
					"pl7.app/vdj/scClonotypeKey/structure": columnsInfo.clonotypeKeyStructure,
					"pl7.app/vdj/vdjImport": blockId
				},
				annotations: {
					"pl7.app/label": "Clonotype ID",
					"pl7.app/table/fontFamily": "monospace",
					"pl7.app/table/visibility": "default",
					"pl7.app/table/orderPriority": "110000",
					"pl7.app/segmentedBy": string(json.encode(["pl7.app/vdj/vdjImport"]))
				}
			}
		}
	}

	receptorsHandled := {}
	for chain in chains {
		receptor := chainToReceptor[chain]
		if is_undefined(receptor) { continue }
		if receptorsHandled[receptor] { continue }
		receptorsHandled[receptor] = true

		chainA := receptor == "IG" ? "IGHeavy" : (receptor == "TCRAB" ? "TCRBeta" : "TCRDelta")
		chainB := receptor == "IG" ? "IGLight" : (receptor == "TCRAB" ? "TCRAlpha" : "TCRGamma")

		hasA := false; hasB := false
		for ch in chains { if ch == chainA { hasA = true }; if ch == chainB { hasB = true } }
		if !(hasA && hasB) { continue }

		scTraceSteps := [{ type: "milaboratories.importVDJ", id: blockId + ".sc." + receptor, importance: 82, label: receptor }]
		scOutputs := [
			{
				type: "Xsv",
				xsvType: "tsv",
				settings: {
					axes: [
						{ column: "sampleId", spec: sampleIdAxisSpec },
						axisByScClonotypeKey(receptor)
					],
					columns: [
						{
							column: "uniqueCellCount",
							spec: {
								name: "pl7.app/vdj/uniqueCellCount",
								valueType: "Long",
								annotations: annot(20100, true, {
									"pl7.app/min": "1",
									"pl7.app/isAbundance": "true",
									"pl7.app/abundance/unit": "cells",
									"pl7.app/abundance/normalized": "false",
									"pl7.app/abundance/isPrimary": "true",
									"pl7.app/isAnchor": "true",
									"pl7.app/label": "Number of Cells"
								})
							}
						},
						{
							column: "uniqueCellFraction",
							spec: {
								name: "pl7.app/vdj/uniqueCellFraction",
								valueType: "Double",
								annotations: annot(20000, false, {
									"pl7.app/min": "0",
									"pl7.app/max": "1",
									"pl7.app/isAbundance": "true",
									"pl7.app/abundance/unit": "cells",
									"pl7.app/abundance/normalized": "true",
									"pl7.app/abundance/isPrimary": "true",
									"pl7.app/label": "Fraction of Cells",
									"pl7.app/format": ".2p"
								})
							}
						}
					],
					storageFormat: "Parquet",
					partitionKeyLength: 1
				},
				mem: "12GiB",
				cpu: 2,
				name: "abundanceTable",
				path: ["abundanceTsv"],
				traceSteps: scTraceSteps
			},
			{
				type: "Xsv",
				xsvType: "tsv",
				settings: {
					axes: [ axisByScClonotypeKey(receptor) ],
					columns: [
						{
							column: "sampleCount",
							spec: {
								name: "pl7.app/vdj/sampleCount",
								valueType: "Int",
								annotations: annot(87110, true, {
									"pl7.app/min": "1",
									"pl7.app/isAbundance": "true",
									"pl7.app/abundance/normalized": "false",
									"pl7.app/abundance/unit": "samples",
									"pl7.app/label": "Number of Samples"
								})
							}
						},
						{
							column: "clonotypeLabel",
							spec: {
								name: "pl7.app/label",
								valueType: "String",
								annotations: annot(100000, false, {
									"pl7.app/label": "Clone label"
								})
							}
						}
					],
					storageFormat: "Parquet",
					partitionKeyLength: 0
				},
				mem: "12GiB",
				cpu: 2,
				name: "aggregates",
				path: ["clonotypeTsv"],
				traceSteps: scTraceSteps
			}
		]

		for chainLetter in ["a", "b"] {
			for pIndex in ["Primary", "Secondary"] {
				tableName := "properties_" + chainLetter + "_" + text.to_lower(pIndex)
				chainNameU := (receptor == "IG" ? (chainLetter == "a" ? "Heavy" : "Light") : (receptor == "TCRAB" ? (chainLetter == "a" ? "Beta" : "Alpha") : (chainLetter == "a" ? "Delta" : "Gamma")))
				pPrefixU := pIndex
				pPrefixL := text.to_lower(pIndex)
				isPrimary := pIndex == "Primary"
				selectedProps := columnsInfo.propertyColumns
				if !isPrimary {
					selectedProps = []
					for col in columnsInfo.propertyColumns { if col.column == "cdr3-aa" || col.column == "cdr3-nt" { selectedProps += [col] } }
				}
				scOutputs += [ {
					type: "Xsv",
					xsvType: "tsv",
					settings: {
						axes: [ axisByScClonotypeKey(receptor) ],
						columns: (func(cols, chainNameU, chainLetterU, pPrefixU, pPrefixL, isPrimary) {
							out := []
							for col in cols {
								originalLabel := ""
								if !is_undefined(col.spec) && !is_undefined(col.spec.annotations) && !is_undefined(col.spec.annotations["pl7.app/label"]) {
									originalLabel = col.spec.annotations["pl7.app/label"]
								}
								isTargetPrimary := (col.column == "cdr3-aa") || (col.column == "v-gene") || (col.column == "j-gene") || (col.column == "d-gene") || (col.column == "c-gene")
								desiredVisibility := (isPrimary && isTargetPrimary) ? "default" : "optional"
								out = append(out, maps.deepMerge(col, {
									spec: {
										domain: {
											"pl7.app/vdj/scClonotypeChain": text.to_upper(chainLetter),
											"pl7.app/vdj/scClonotypeChain/index": pPrefixL
										},
										annotations: {
											"pl7.app/label": chainNameU + " " + originalLabel + " " + pPrefixU,
											"pl7.app/table/visibility": desiredVisibility,
											"pl7.app/parents": undefined
										}
									}
								}))
							}
							return out
						})(selectedProps, chainNameU, text.to_upper(chainLetter), pPrefixU, pPrefixL, isPrimary),
						storageFormat: "Parquet",
						partitionKeyLength: 0
					},
					mem: "12GiB",
					cpu: 2,
					name: tableName,
					path: ["properties" + text.to_upper(chainLetter) + pIndex + "Tsv"],
					traceSteps: scTraceSteps
				} ]
			}
		}

		// cells linker table
		scOutputs += [
			{
				type: "Xsv",
				xsvType: "tsv",
				settings: {
					axes: [
						{ column: "sampleId", spec: sampleIdAxisSpec },
						{ column: "cellKey", spec: { name: "pl7.app/sc/cellId", type: "String" } },
						axisByScClonotypeKey(receptor)
					],
					columns: [
						{
							column: "1",
							spec: {
								name: "pl7.app/sc/cellLinker",
								valueType: "Int",
								annotations: { "pl7.app/isLinkerColumn": "true" }
							}
						}
					],
					storageFormat: "Parquet",
					partitionKeyLength: 1
				},
				mem: "12GiB",
				cpu: 2,
				name: "cellsLinkerTable",
				path: ["cellsTsv"],
				traceSteps: scTraceSteps
			}
		]

		scResult := pframes.processColumn(
			importResults.output("clonotypesTsvForSingleCell-" + chainA),
			processSingleCellKeysTpl,
			scOutputs,
			{
				aggregate: ["pl7.app/sampleId"],
				traceSteps: [{ type: "milaboratories.import-vdj-data.processSingleCell", id: blockId + "." + receptor, importance: 80, label: receptor }],
				extra: {
					byCellTagB: importResults.output("clonotypesTsvForSingleCell-" + chainB).data,
					propertiesA: pframes.processColumn(
						importResults.output("clonotypesTsv-" + chainA),
						aggregateByClonotypeKeyTpl,
						[
							{
								type: "Resource",
								spec: { kind: "PColumn", name: "mixcr.com/clonotypeProperties", valueType: "File" },
								name: "clonotypeProperties",
								path: ["tsv"]
							}
						],
						{
							aggregate: ["pl7.app/sampleId"],
							extra: {
								primaryAbundance: mainAbundanceCount,
								primaryFraction: mainAbundanceFraction,
								schema: columnsSchema
							}
						}
					).outputData("clonotypeProperties"),
					propertiesB: pframes.processColumn(
						importResults.output("clonotypesTsv-" + chainB),
						aggregateByClonotypeKeyTpl,
						[
							{
								type: "Resource",
								spec: { kind: "PColumn", name: "mixcr.com/clonotypeProperties", valueType: "File" },
								name: "clonotypeProperties",
								path: ["tsv"]
							}
						],
						{
							aggregate: ["pl7.app/sampleId"],
							extra: {
								primaryAbundance: mainAbundanceCount,
								primaryFraction: mainAbundanceFraction,
								schema: columnsSchema
							}
						}
					).outputData("clonotypeProperties"),
					params: {
						mainAbundanceColumn: mainAbundanceCount,
						mainIsProductiveColumn: "is-productive",
						schemaPerClonotypeNoAggregates: columnsSchema
					}
				}
			}
		)

		for columnName in scResult.listXsvColumns("abundanceTable") { result.add("clonotypeProperties/abundance/" + receptor + "/" + columnName, scResult.outputSpec("abundanceTable", columnName), scResult.outputData("abundanceTable", columnName)) }
		scResult.addXsvOutputToBuilder(result, "aggregates", "clonotypeProperties/aggregates/" + receptor + "/")
		scResult.addXsvOutputToBuilder(result, "properties_a_primary", "clonotypeProperties/" + receptor + "/aPrimary/")
		scResult.addXsvOutputToBuilder(result, "properties_a_secondary", "clonotypeProperties/" + receptor + "/aSecondary/")
		scResult.addXsvOutputToBuilder(result, "properties_b_primary", "clonotypeProperties/" + receptor + "/bPrimary/")
		scResult.addXsvOutputToBuilder(result, "properties_b_secondary", "clonotypeProperties/" + receptor + "/bSecondary/")
		for columnName in scResult.listXsvColumns("cellsLinkerTable") {
			result.add("clonotypeProperties/" + receptor + "/cellsLinkerTable/" + columnName, scResult.outputSpec("cellsLinkerTable", columnName), scResult.outputData("cellsLinkerTable", columnName))
		}
	}

	return { result: result.build(), stats: stats.build() }
})
