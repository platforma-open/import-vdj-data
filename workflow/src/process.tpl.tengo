// process

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
sets := import("@platforma-sdk/workflow-tengo:sets")
assets := import("@platforma-sdk/workflow-tengo:assets")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")

json := import("json")
text := import("text")

immunoSeqTpl := assets.importTemplate(":import-immunoSeq")
qiagenTpl := assets.importTemplate(":import-qiagen")
customTpl := assets.importTemplate(":import-custom")
mixcrTpl := assets.importTemplate(":import-mixcr")
cellrangerTpl := assets.importTemplate(":import-cellranger")
aggregateByClonotypeKeyTpl := assets.importTemplate(":aggregate-by-clonotype-key")
processSingleCellTpl := assets.importTemplate(":process-single-cell")

// Helper to add common annotations for table view properties
a := func(order, defaultVisibility, spec) {
	return maps.merge(spec, {
		"pl7.app/table/orderPriority": string(order),
		"pl7.app/table/visibility": is_undefined(defaultVisibility) ? "hidden" : defaultVisibility ? "default" : "optional"
	})
}

abundanceAggColumns := func(columnsInfo) {
    aggColumns := []
    unit2label := {
        "molecules": "UMIs",
        "reads": "Reads"
    }
    for column in columnsInfo.abundanceColumns {
        if column.spec.annotations["pl7.app/abundance/isPrimary"] != "true" {
            continue
        }

        unit := column.spec.annotations["pl7.app/abundance/unit"]
        descUnit := unit == "molecules" ? "UMI" : "read"
        if column.spec.annotations["pl7.app/abundance/normalized"] == "false" {
            aggColumns += [{
                column: column.column + "-total",
                id: column.id + "-total",
                allowNA: false,
                spec: {
                    name: column.spec.name + "Total",
                    valueType: "Long",
                    annotations: a(87120, false, {
                        "pl7.app/min": "1",
                        "pl7.app/isAbundance": "true",
                        "pl7.app/abundance/unit": unit,
                        "pl7.app/abundance/normalized": "false",
                        "pl7.app/label": "Supporting " + unit2label[unit],
                        "pl7.app/description": "The sum of a clonotype's " + descUnit + " counts across all samples."
                    })
                }
            }]
        } else {
            aggColumns += [{
                column: column.column + "-mean",
                id: column.id + "-mean",
                allowNA: false,
                spec: {
                    name: column.spec.name + "Mean",
                    valueType: "Double",
                    annotations: a(87130, false, {
                        "pl7.app/min": "0",
                        "pl7.app/max": "1",
                        "pl7.app/isAbundance": "true",
                        "pl7.app/abundance/unit": unit,
                        "pl7.app/abundance/normalized": "true",
                        "pl7.app/label": "Mean Fraction of " + unit2label[unit],
                        "pl7.app/description": "The average " + descUnit + " fraction of a clonotype across all samples where it is present.",
                        "pl7.app/format": ".2p"
                    })
                }
            }]
        }
    }
    return aggColumns
}

columnsToSchema := func(columns) {
    schema := []
    for col in columns {
        schema += [ { column: col.column, type: col.spec.valueType } ]
    }
    return schema
}

self.awaitState("InputsLocked")
self.awaitState("columnsInfo", "ResourceReady")
self.awaitState("dataset", "ResourceReady")


self.body(func(inputs) {

    // chains to import
	chains := inputs.chains
    columnsInfo := inputs.columnsInfo
    datasetSpec := inputs.dataset.spec
    dataset := inputs.dataset.data
	format := inputs.format
    blockId := inputs.blockId

     // Single-cell detection (still used below), but we always export per-chain abundance to avoid empty outputs.
    isSingleCell := !is_undefined(columnsInfo.cellTagColumns) && len(columnsInfo.cellTagColumns) > 0

    importTpl := undefined
    if format == "immunoSeq" {
        importTpl = immunoSeqTpl
    } else if format == "qiagen" {
        importTpl = qiagenTpl
    } else if format == "custom" {
        importTpl = customTpl
    } else if format == "mixcr" {
        importTpl = mixcrTpl
    } else if format == "cellranger" {
        importTpl = cellrangerTpl
    }

    if importTpl == undefined {
        ll.panic("Import template is undefined, format: " + format)
    }

    result := pframes.pFrameBuilder()
    stats := pframes.pFrameBuilder()

    importOutputs := []

    for chain in chains {

        axes := [
            {
                column: "clonotypeKey",
                naRegex: "",
                spec: {
                    type: "String",
                    name: "pl7.app/vdj/clonotypeKey",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/vdjImport": blockId,
                        "pl7.app/vdj/clonotypeKey/structure": columnsInfo.clonotypeKeyStructure
                    },
                    annotations: {
                        "pl7.app/label": "Clonotype ID",
                        "pl7.app/description": "A composite key that uniquely identifies a clonotype."
                    }
                }
            }
        ]

        hasReads := columnsInfo.columnMapping["read-count"] != undefined

        statsColumns := [{
            id: "clonotype-count",
            column: "clonotype-count",
            spec: {
                name: "pl7.app/vdj/stat/clonotypeCount",
                valueType: "Int",
                domain: {
                    "pl7.app/vdj/chain": chain,
                    "pl7.app/vdj/vdjImport": blockId
                },
                annotations: {
                    "pl7.app/label": "Number of Clonotypes",
                    "pl7.app/description": "The number of clonotypes in the dataset.",
                    "pl7.app/table/visibility": "default"
                }
            }
        }]

        if hasReads {
            statsColumns += [{
                id: "read-count",
                column: "read-count",
                spec: {
                    name: "pl7.app/vdj/stat/readCount",
                    valueType: "Int",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/vdjImport": blockId
                    },
                    annotations: {
                        "pl7.app/label": "Number of Reads",
                        "pl7.app/description": "The number of reads in the dataset.",
                        "pl7.app/table/visibility": "default"
                    }
                }
            }]
        }

        if columnsInfo.hasUMIs {
            statsColumns += [{
                id: "umi-count",
                column: "umi-count",
                spec: {
                    name: "pl7.app/vdj/stat/umiCount",
                    valueType: "Float",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/vdjImport": blockId
                    },
                    annotations: {
                        "pl7.app/label": "Number of UMIs",
                        "pl7.app/description": "The number of UMIs in the dataset.",
                        "pl7.app/table/visibility": "default"
                    }
                }
            }]
        }

        traceSteps := [{
			type: "milaboratories.importVDJ",
            id: blockId + ".chain",
			importance: 81,
			label: chain
		}]

        importOutputs += [
            {
                type: "Resource",
                spec: {
                    kind: "PColumn",
                    name: "mixcr.com/clonotypeTable",
                    valueType: "File"
                },
                name: "clonotypesTsv-" + chain,
                path: ["tsv", chain]
            },
            {
                type: "Resource",
                spec: {
                    kind: "PColumn",
                    name: "mixcr.com/clonotypeTableForSingleCell",
                    valueType: "File"
                },
                name: "clonotypesTsvForSingleCell-" + chain,
                path: ["tsvForSingleCell", chain]
            },
            {
                type: "TsvContent",
                settings: {
                    axes: [],
                    columns: statsColumns
                },
                traceSteps: traceSteps,
                name: "stats-" + chain,
                path: ["stats", chain]
            },
            {
                type: "Xsv",
                xsvType: "tsv",
                settings: {
                    axes: axes,
                    // override trace to include chain name
                    columns: columnsInfo.abundanceColumns,
                    storageFormat: "Binary",
                    partitionKeyLength: 0
                },
                traceSteps: traceSteps,
                mem: "16GiB",
                cpu: 2,
                name: "abundance-" + chain,
                path: ["tsv", chain]
        }]
    }

	importResults := pframes.processColumn(
		{
            spec: datasetSpec,
            data: dataset
        },
		importTpl,
		importOutputs,
		{
            // @todo all tags
            aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/tag",
				optional: true
			}],

			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			extra: {
                columnsInfo: columnsInfo,
                chains: chains
            }
		}
	)

    // Always export stats for main page table
    for chain in chains {
        importResults.addXsvOutputToBuilder(stats, "stats-" + chain, "stats-" + chain)
    }
    // Export per-chain abundance only in bulk mode
    if !isSingleCell {
        for chain in chains {
            importResults.addXsvOutputToBuilder(result, "abundance-" + chain, "abundance-" + chain)
        }
    }

    for chain in chains {
        axes := [
            {
                column: "clonotypeKey",
                allowNA: false,
                spec: {
                    type: "String",
                    name: "pl7.app/vdj/clonotypeKey",
                    domain: {
                        "pl7.app/vdj/chain": chain,
                        "pl7.app/vdj/vdjImport": blockId,
                        "pl7.app/vdj/clonotypeKey/structure": columnsInfo.clonotypeKeyStructure
                    },
                    annotations: {
                        "pl7.app/label": "Clonotype ID",
                        "pl7.app/description": "A composite key that uniquely identifies a clonotype."
                    }
                }
            }
        ]

        propertyColumns := columnsInfo.propertyColumns
        propertyColumns += [
            {
                id: "sampleCount",
                column: "sampleCount",
                spec: {
                    name: "pl7.app/vdj/sampleCount",
                    valueType: "Int",
                    annotations: {
                        "pl7.app/label": "Number of Samples",
                        "pl7.app/description": "The number of samples in which the clonotype is detected.",
                        "pl7.app/abundance/normalized": "false",
                        "pl7.app/abundance/unit": "samples",
                        "pl7.app/isAbundance": "true",
                        "pl7.app/min": "1",
                        "pl7.app/table/orderPriority": "87110",
                        "pl7.app/table/visibility": "optional"
                    }
                }
            }, {
                id: "clonotypeLabel",
                column: "clonotypeLabel",
                spec: {
                    name: "pl7.app/label",
                    valueType: "String",
                    annotations: {
                        "pl7.app/label": "Clonotype ID",
                        "pl7.app/description": "A short, human-readable label for the clonotype."
                    }
                }
        }]

        aggAbundanceColumns := abundanceAggColumns(columnsInfo)

        aggOutputs := []
        if !isSingleCell {
            aggOutputs = [{
                type: "Xsv",
                xsvType: "tsv",
                settings: {
                    axes: axes,
                    columns: propertyColumns + aggAbundanceColumns,
                    storageFormat: "Binary",
                    partitionKeyLength: 0
                },
                mem: "16GiB",
                cpu: 2,
                name: "properties-" + chain,
                path: ["tsv"]
            }]
        }

        // Derive primary abundance names from columnsInfo primary flags to keep consistency
        mainAbundanceCount := "read-count"
        mainAbundanceFraction := "read-fraction"
        for col in columnsInfo.abundanceColumns {
            if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "false" {
                mainAbundanceCount = col.column
            }
            if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "true" {
                mainAbundanceFraction = col.column
            }
        }

        aggResults := pframes.processColumn(
            importResults.output("clonotypesTsv-" + chain),
            aggregateByClonotypeKeyTpl,
            aggOutputs,
            {
                aggregate: ["pl7.app/sampleId"],

                traceSteps: [{type: "milaboratories.importVDJ",  id: blockId + "." + chain, importance: 81, label: chain}],

                extra: {
                    primaryAbundance: mainAbundanceCount,
                    primaryFraction: mainAbundanceFraction,
                    schema: columnsToSchema(propertyColumns)
                }
            }
        )

        if !isSingleCell {
            aggResults.addXsvOutputToBuilder(result, "properties-" + chain, "properties-" + chain)
        }
    }

    // Single-cell branch
    if isSingleCell {
        chainToReceptor := {
            "IGHeavy": "IG",
            "IGLight": "IG",
            "TRA": "TCRAB",
            "TRB": "TCRAB",
            "TRD": "TCRGD",
            "TRG": "TCRGD"
        }

        mainAbundanceCount := "read-count"
        mainAbundanceFraction := "read-fraction"
        for col in columnsInfo.abundanceColumns {
            if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "false" { mainAbundanceCount = col.column }
            if col.spec.annotations["pl7.app/abundance/isPrimary"] == "true" && col.spec.annotations["pl7.app/abundance/normalized"] == "true" { mainAbundanceFraction = col.column }
        }

        columnsSchema := columnsToSchema(columnsInfo.propertyColumns)

        // Reuse the input's sampleId axis spec to ensure identical axis metadata
        sampleIdAxisSpec := inputs.dataset.spec.axesSpec[0]
        axisByScClonotypeKey := func(receptor) {
            return {
                column: "scClonotypeKey",
                naRegex: "",
                spec: {
                    name: "pl7.app/vdj/scClonotypeKey",
                    type: "String",
                    domain: {
                        "pl7.app/vdj/receptor": receptor,
                        "pl7.app/vdj/scClonotypeKey/structure": columnsInfo.clonotypeKeyStructure,
                        "pl7.app/vdj/vdjImport": blockId
                    },
                    annotations: {
                        "pl7.app/label": "Clonotype ID",
                        "pl7.app/table/fontFamily": "monospace",
                        "pl7.app/table/visibility": "default",
                        "pl7.app/table/orderPriority": "110000",
                        "pl7.app/segmentedBy": string(json.encode(["pl7.app/vdj/vdjImport"]))
                    }
                }
            }
        }

        receptorsHandled := {}
        for chain in chains {
            receptor := chainToReceptor[chain]
            if is_undefined(receptor) { continue }
            if receptorsHandled[receptor] { continue }
            receptorsHandled[receptor] = true

            chainA := receptor == "IG" ? "IGHeavy" : (receptor == "TCRAB" ? "TRB" : "TRD")
            chainB := receptor == "IG" ? "IGLight" : (receptor == "TCRAB" ? "TRA" : "TRG")

            hasA := false
            hasB := false
            for ch in chains {
                if ch == chainA {
                    hasA = true
                }
                if ch == chainB {
                    hasB = true
                }
            }
            if !(hasA && hasB) { continue }

            scTraceSteps := [{ type: "milaboratories.importVDJ", id: blockId + ".sc." + receptor, importance: 82, label: receptor }]

            scOutputs := [
                { type: "Xsv", xsvType: "tsv", settings: { axes: [ { column: "sampleId", spec: sampleIdAxisSpec }, axisByScClonotypeKey(receptor) ], columns: [ { column: "uniqueCellCount", spec: { name: "pl7.app/vdj/uniqueCellCount", valueType: "Long", annotations: a(20100, true, { "pl7.app/min": "1", "pl7.app/isAbundance": "true", "pl7.app/abundance/unit": "cells", "pl7.app/abundance/normalized": "false", "pl7.app/abundance/isPrimary": "true", "pl7.app/isAnchor": "true", "pl7.app/label": "Number of Cells" }) } }, { column: "uniqueCellFraction", spec: { name: "pl7.app/vdj/uniqueCellFraction", valueType: "Double", annotations: a(20000, false, { "pl7.app/min": "0", "pl7.app/max": "1", "pl7.app/isAbundance": "true", "pl7.app/abundance/unit": "cells", "pl7.app/abundance/normalized": "true", "pl7.app/abundance/isPrimary": "true", "pl7.app/label": "Fraction of Cells", "pl7.app/format": ".2p" }) } } ], storageFormat: "Binary", partitionKeyLength: 1 }, mem: "12GiB", cpu: 2, name: "abundanceTable", path: ["abundanceTsv"], traceSteps: scTraceSteps },
                { type: "Xsv", xsvType: "tsv", settings: { axes: [ axisByScClonotypeKey(receptor) ], columns: [ { column: "sampleCount", spec: { name: "pl7.app/vdj/sampleCount", valueType: "Int", annotations: a(87110, true, { "pl7.app/min": "1", "pl7.app/isAbundance": "true", "pl7.app/abundance/normalized": "false", "pl7.app/abundance/unit": "samples", "pl7.app/label": "Number of Samples" }) } }, { column: "clonotypeLabel", spec: { name: "pl7.app/label", valueType: "String", annotations: a(100000, false, { "pl7.app/label": "Clone label" }) } } ], storageFormat: "Binary", partitionKeyLength: 0 }, mem: "12GiB", cpu: 2, name: "aggregates", path: ["clonotypeTsv"], traceSteps: scTraceSteps }
            ]

            // SC properties per chain/index
            buildScColumns := func(cols, chainNameU, chainLetterU, pPrefixU, pPrefixL, isPrimary) {
                out := []
                for col in cols {
                    originalLabel := ""
                    if !is_undefined(col.spec) && !is_undefined(col.spec.annotations) && !is_undefined(col.spec.annotations["pl7.app/label"]) { originalLabel = col.spec.annotations["pl7.app/label"] }
                    // Only primary CDR3 aa and best V/J/D/C genes should be visible by default; everything else optional
                    isTargetPrimary := (col.column == "cdr3-aa") || (col.column == "v-gene") || (col.column == "j-gene") || (col.column == "d-gene") || (col.column == "c-gene")
                    desiredVisibility := (isPrimary && isTargetPrimary) ? "default" : "optional"
                    out = append(out, maps.deepMerge(col, { spec: { domain: { "pl7.app/vdj/scClonotypeChain": chainLetterU, "pl7.app/vdj/scClonotypeChain/index": pPrefixL }, annotations: { "pl7.app/label": chainNameU + " " + originalLabel + " " + pPrefixU, "pl7.app/table/visibility": desiredVisibility, "pl7.app/parents": undefined } } }))
                }
                return out
            }

            resolveScChainNameU := func(receptor, chainLetterU) {
                if receptor == "IG" { return chainLetterU == "A" ? "Heavy" : "Light" } else if receptor == "TCRAB" { return chainLetterU == "A" ? "Beta" : "Alpha" } else if receptor == "TCRGD" { return chainLetterU == "A" ? "Delta" : "Gamma" }
                return chainLetterU
            }

            for chainLetter in ["a", "b"] {
                for pIndex in ["Primary", "Secondary"] {
                    tableName := "properties_" + chainLetter + "_" + text.to_lower(pIndex)
                    chainNameU := resolveScChainNameU(receptor, text.to_upper(chainLetter))
                    pPrefixU := pIndex
                    pPrefixL := text.to_lower(pIndex)
                    isPrimary := pIndex == "Primary"
                    selectedProps := columnsInfo.propertyColumns
                    if !isPrimary {
                        selectedProps = []
                        for col in columnsInfo.propertyColumns {
                            if col.column == "cdr3-aa" || col.column == "cdr3-nt" {
                                selectedProps += [col]
                            }
                        }
                    }
                    scOutputs += [ { 
                        type: "Xsv", 
                        xsvType: "tsv", 
                        settings: { 
                            axes: [ axisByScClonotypeKey(receptor) ], 
                            columns: buildScColumns(selectedProps, chainNameU, text.to_upper(chainLetter), pPrefixU, pPrefixL, isPrimary), 
                            storageFormat: "Binary", 
                            partitionKeyLength: 0 
                            }, 
                        mem: "12GiB", 
                        cpu: 2, 
                        name: tableName, 
                        path: ["properties" + text.to_upper(chainLetter) + pIndex + "Tsv"], 
                        traceSteps: scTraceSteps 
                    } ]
                }
            }

            scOutputs += [ { 
                type: "Xsv", 
                xsvType: "tsv", 
                settings: { 
                    axes: [ { column: "sampleId", spec: sampleIdAxisSpec }, { column: "cellKey", spec: { name: "pl7.app/sc/cellId", type: "String" } }, axisByScClonotypeKey(receptor) ], 
                    columns: [ { column: "1", spec: { name: "pl7.app/sc/cellLinker", valueType: "Int", annotations: { "pl7.app/isLinkerColumn": "true" } } } ], 
                    storageFormat: "Binary", 
                    partitionKeyLength: 1 
                    }, 
                mem: "12GiB", 
                cpu: 2, 
                name: "cellsLinkerTable", 
                path: ["cellsTsv"], 
                traceSteps: scTraceSteps 
            } ]
            
            traceStepsSc := [{
                type: "milaboratories.import-vdj-data.processSingleCell", 
                id: blockId + "." + receptor, 
                importance: 80, 
                label: receptor
                }]

            scResult := pframes.processColumn(
                importResults.output("clonotypesTsvForSingleCell-" + chainA),
                processSingleCellTpl,
                scOutputs,
                { 
                    aggregate: ["pl7.app/sampleId"], 
                    traceSteps: traceStepsSc, 
                    extra: { 
                        byCellTagB: importResults.output("clonotypesTsvForSingleCell-" + chainB).data, 
                        propertiesA: pframes.processColumn(
                            importResults.output("clonotypesTsv-" + chainA), 
                            aggregateByClonotypeKeyTpl, 
                            [{ type: "Resource", spec: { kind: "PColumn", name: "mixcr.com/clonotypeProperties", valueType: "File" }, name: "clonotypeProperties", path: ["tsv"] }], 
                            { 
                                aggregate: ["pl7.app/sampleId"], 
                                extra: { 
                                    primaryAbundance: mainAbundanceCount, 
                                    primaryFraction: mainAbundanceFraction, 
                                    schema: columnsSchema } }).outputData("clonotypeProperties"), 
                        propertiesB: pframes.processColumn(
                            importResults.output("clonotypesTsv-" + chainB), 
                            aggregateByClonotypeKeyTpl, 
                            [{ type: "Resource", spec: { kind: "PColumn", name: "mixcr.com/clonotypeProperties", valueType: "File" }, name: "clonotypeProperties", path: ["tsv"] }], 
                            { 
                                aggregate: ["pl7.app/sampleId"], 
                                extra: { 
                                    primaryAbundance: mainAbundanceCount, 
                                    primaryFraction: mainAbundanceFraction, 
                                    schema: columnsSchema } }).outputData("clonotypeProperties"), 
                        params: { 
                            mainAbundanceColumn: mainAbundanceCount, 
                            mainIsProductiveColumn: "is-productive", 
                            schemaPerClonotypeNoAggregates: columnsSchema 
                        }
                    } 
                }
            )

            for columnName in scResult.listXsvColumns("abundanceTable") {
                result.add("clonotypeProperties/abundance/" + receptor + "/" + columnName, scResult.outputSpec("abundanceTable", columnName), scResult.outputData("abundanceTable", columnName))
            }
            scResult.addXsvOutputToBuilder(result, "aggregates", "clonotypeProperties/aggregates/" + receptor + "/")
            scResult.addXsvOutputToBuilder(result, "properties_a_primary", "clonotypeProperties/" + receptor + "/aPrimary/")
            scResult.addXsvOutputToBuilder(result, "properties_a_secondary", "clonotypeProperties/" + receptor + "/aSecondary/")
            scResult.addXsvOutputToBuilder(result, "properties_b_primary", "clonotypeProperties/" + receptor + "/bPrimary/")
            scResult.addXsvOutputToBuilder(result, "properties_b_secondary", "clonotypeProperties/" + receptor + "/bSecondary/")
            for columnName in scResult.listXsvColumns("cellsLinkerTable") {
                result.add("clonotypeProperties/" + receptor + "/cellsLinkerTable/" + columnName, scResult.outputSpec("cellsLinkerTable", columnName), scResult.outputData("cellsLinkerTable", columnName))
            }
        }
    }

    return {
        result: result.build(),
        stats: stats.build()
    }
})
